version: '3'

# Hono + Datastar — Tri-mode deployment
#
# Prerequisites:
#   - task (https://taskfile.dev) — the ONLY prerequisite
#   - Bun is auto-installed by `task deps` if not present
#
# Quick start:
#   task deps          # install Bun + all dependencies
#   task cf:dev        # Cloudflare Workers dev server (port 8787)
#   task fly:dev       # Bun server with persistent SSE (port 3000)
#   task sw:dev        # build Service Worker + start dev server
#   task test          # 25 e2e tests against Workers
#   task fly:test      # same 25 e2e tests against Bun
#
# All tasks are idempotent — safe to run multiple times.

# Ensure ~/.bun/bin is on PATH so freshly-installed Bun is found immediately
env:
  PATH:
    sh: echo "$HOME/.bun/bin:$PATH"

vars:
  # Cloudflare Workers
  D1_DB: test-hono-db
  CF_LOG: .wrangler/wrangler.log
  CF_URL: http://localhost:8787
  CF_DEPLOYED_URL: '{{.CF_DEPLOYED_URL | default "https://test-hono.gedw99.workers.dev"}}'
  # Fly.io / Bun
  FLY_APP: test-hono-bun
  FLY_REGION: sjc
  FLY_DB_PATH: ./data/counter.db
  FLY_PORT: "3000"
  FLY_URL: http://localhost:3000
  FLY_LOG: .wrangler/bun.log
  FLY_DEPLOYED_URL: '{{.FLY_DEPLOYED_URL | default "https://test-hono-bun.fly.dev"}}'
  # Corrosion
  CORROSION_VERSION: "v1.0.0"
  CORROSION_DOWNLOAD_URL: "https://github.com/joeblew999/binary-corrosion/releases/download/{{.CORROSION_VERSION}}/corrosion-{{.CORROSION_VERSION}}-{{.OS}}-amd64.zip"
  CORROSION_BIN: "./bin/corrosion"
  CORROSION_DATA_DIR: "./corrosion_data"
  CORROSION_AGENT_URL: "http://localhost:8080"
  CORROSION_PORT: "8080"
  CORROSION_LOG: ".wrangler/corrosion.log"

tasks:
  default:
    desc: "List all available tasks"
    cmds:
      - task --list-all
    silent: true

  # ╔══════════════════════════════════════════════╗
  # ║  Setup                                       ║
  # ╚══════════════════════════════════════════════╝

  deps:
    desc: "Install Bun (if needed) + all dependencies + Playwright"
    cmds:
      - task: bun:install
      - |
        export PATH="$HOME/.bun/bin:$PATH"
        bun install
        bunx playwright install --with-deps chromium

  bun:install:
    desc: "Install Bun if not already present"
    cmds:
      - |
        if command -v bun &>/dev/null; then
          echo "Bun $(bun --version) already installed"
          exit 0
        fi
        echo "Installing Bun..."
        curl -fsSL https://bun.sh/install | bash
        echo "Bun installed to ~/.bun/bin/bun"
    silent: true

  # ╔══════════════════════════════════════════════╗
  # ║  Cloudflare Workers (cf:)                    ║
  # ╚══════════════════════════════════════════════╝

  cf:dev:
    desc: "Start Workers dev server with live logs (port 8787)"
    cmds:
      - task: cf:stop
      - task: cf:start
      - task: cf:logs

  cf:start:
    desc: "Start Workers server in background (skips if running)"
    cmds:
      - |
        if curl -s -o /dev/null -w '' {{.CF_URL}}/ 2>/dev/null; then
          echo "Server already running at {{.CF_URL}}"
          exit 0
        fi
        mkdir -p .wrangler
        bunx wrangler d1 migrations apply {{.D1_DB}} --local
        bun run dev > {{.CF_LOG}} 2>&1 &
        for i in $(seq 1 15); do
          curl -s -o /dev/null -w '' {{.CF_URL}}/ 2>/dev/null && break
          sleep 1
        done
        echo "Server ready at {{.CF_URL}}"
    silent: true

  cf:stop:
    desc: "Stop Workers dev server"
    cmds:
      - pkill -f "wrangler dev" || true
    silent: true

  cf:restart:
    desc: "Stop and restart Workers dev server"
    cmds:
      - task: cf:stop
      - sleep 1
      - task: cf:start

  cf:logs:
    desc: "Follow Workers dev server logs"
    cmds:
      - tail -f {{.CF_LOG}}

  cf:test:
    desc: "Run 25 e2e tests headed + serial against Workers"
    cmds:
      - task: cf:start
      - bun run test

  cf:test:ci:
    desc: "Run 25 e2e tests headless + parallel (fast, for CI)"
    cmds:
      - task: cf:start
      - HEADED=0 bun run test

  cf:test:deployed:
    desc: "Run e2e tests against deployed Workers ({{.CF_DEPLOYED_URL}})"
    summary: |
      Usage:
        task cf:test:deployed                              # uses CF_DEPLOYED_URL
        task cf:test:deployed -- https://your.workers.dev  # override URL
    cmds:
      - echo "Testing against {{if .CLI_ARGS}}{{.CLI_ARGS}}{{else}}{{.CF_DEPLOYED_URL}}{{end}}"
      - HEADED=0 BASE_URL={{if .CLI_ARGS}}{{.CLI_ARGS}}{{else}}{{.CF_DEPLOYED_URL}}{{end}} bun run test

  cf:login:
    desc: "Authenticate with Cloudflare (skips if logged in)"
    cmds:
      - |
        if bunx wrangler whoami &>/dev/null; then
          echo "Already authenticated with Cloudflare"
          bunx wrangler whoami
          exit 0
        fi
        bunx wrangler login
    silent: true

  cf:deploy:
    desc: "Deploy to Cloudflare Workers (runs remote migrations first)"
    cmds:
      - bunx wrangler d1 migrations apply {{.D1_DB}} --remote
      - bun run deploy

  cf:screenshots:
    desc: "Capture screenshots at 3 viewports to docs/screenshots/"
    cmds:
      - task: cf:start
      - mkdir -p docs/screenshots
      - bunx playwright test --config=playwright.screenshots.ts --headed
      - echo "Screenshots saved to docs/screenshots/"

  cf:videos:
    desc: "Record test run videos as flat GIFs in docs/videos/"
    cmds:
      - task: cf:start
      - rm -rf docs/videos
      - mkdir -p docs/videos
      - bunx playwright test --config=playwright.videos.ts
      - |
        echo "Converting webm → gif (flat, clean names)..."
        cd docs/videos
        for dir in */; do
          name="${dir%/}"
          webm="$dir/video.webm"
          [ -f "$webm" ] || continue

          # Derive clean name
          clean="$name"
          # Remove double prefix (counter-counter- → counter-, notes-notes- → notes-, auth-auth- → auth-)
          clean=$(echo "$clean" | sed 's/^counter-counter-/counter-/' | sed 's/^notes-notes-/notes-/' | sed 's/^auth-auth-/auth-/')
          # Remove "should-"
          clean=$(echo "$clean" | sed 's/-should-/-/')
          # Remove trailing "-on-click"
          clean=$(echo "$clean" | sed 's/-on-click$//')
          # Clean SW names (Playwright truncates + hashes these)
          case "$name" in
            *offline*seed*) clean="sw-offline" ;;
            *through-SW*) clean="sw-notes-crud" ;;
            *IndexedDB*) clean="sw-persistence" ;;
            *real-server*) clean="sw-sync" ;;
          esac

          # Convert webm → gif (two-pass palette for quality)
          ffmpeg -y -i "$webm" -vf "fps=10,scale=1280:-1:flags=lanczos,palettegen" -loglevel error "/tmp/pw_palette.png"
          ffmpeg -y -i "$webm" -i "/tmp/pw_palette.png" -lavfi "fps=10,scale=1280:-1:flags=lanczos[x];[x][1:v]paletteuse" -loglevel error "${clean}.gif"
          rm -f "/tmp/pw_palette.png"
          rm -rf "$name"
        done
        rm -f .last-run.json
      - echo "GIFs saved to docs/videos/ ($(du -sh docs/videos | cut -f1))"

  cf:sync-demo:
    desc: "Record two-tab sync demo as side-by-side GIF"
    cmds:
      - task: cf:start
      - rm -rf docs/videos/sync-tab-a docs/videos/sync-tab-b
      - bunx playwright test --config=playwright.sync-demo.ts
      - |
        echo "Combining Tab A + Tab B side by side..."
        VID_A=$(ls docs/videos/sync-tab-a/*.webm | head -1)
        VID_B=$(ls docs/videos/sync-tab-b/*.webm | head -1)
        ffmpeg -y -i "$VID_A" -i "$VID_B" \
          -filter_complex "[0:v][1:v]hstack=inputs=2" \
          -loglevel error /tmp/sync_combined.webm
        ffmpeg -y -i /tmp/sync_combined.webm -vf "fps=10,palettegen" -loglevel error /tmp/sync_palette.png
        ffmpeg -y -i /tmp/sync_combined.webm -i /tmp/sync_palette.png \
          -lavfi "fps=10[x];[x][1:v]paletteuse" -loglevel error docs/videos/sync-demo.gif
        rm -f /tmp/sync_combined.webm /tmp/sync_palette.png
        rm -rf docs/videos/sync-tab-a docs/videos/sync-tab-b
      - echo "Sync demo: docs/videos/sync-demo.gif ($(du -h docs/videos/sync-demo.gif | cut -f1))"

  cf:docs:
    desc: "Generate all documentation assets (screenshots + videos + sync demo)"
    cmds:
      - task: cf:screenshots
      - task: cf:videos
      - task: cf:sync-demo
      - echo "All docs generated — screenshots + videos + sync demo"

  cf:ci:secrets:
    desc: "Set Cloudflare API token + account ID as GitHub secrets"
    summary: |
      Automates the full CI setup:
        1. Gets account ID from your local wrangler login
        2. Opens a browser to create an API token (automated via Playwright)
        3. Sets both as GitHub secrets via gh CLI

      Usage:
        task cf:ci:secrets                    # fully automated (opens browser)
        task cf:ci:secrets -- YOUR_API_TOKEN  # skip browser, use existing token
    cmds:
      - |
        ACCOUNT_ID=$(bunx wrangler whoami 2>/dev/null | grep -oE '[a-f0-9]{32}' | head -1)
        if [ -z "$ACCOUNT_ID" ]; then
          echo "Not logged in to Cloudflare. Run 'task cf:login' first."
          exit 1
        fi
        echo "Account ID: $ACCOUNT_ID"

        API_TOKEN="{{.CLI_ARGS}}"
        if [ -z "$API_TOKEN" ]; then
          echo ""
          echo "Opening browser to create API token..."
          API_TOKEN=$(bun scripts/create-cf-token.ts 2>/dev/tty) || true
        fi

        if [ -z "$API_TOKEN" ]; then
          echo ""
          printf "Paste your API token (or Ctrl+C to abort): "
          read -r API_TOKEN
        fi

        if [ -z "$API_TOKEN" ]; then
          echo "No API token provided."
          exit 1
        fi

        echo "$ACCOUNT_ID" | gh secret set CLOUDFLARE_ACCOUNT_ID
        echo "$API_TOKEN" | gh secret set CLOUDFLARE_API_TOKEN
        echo ""
        echo "GitHub secrets set:"
        echo "  CLOUDFLARE_ACCOUNT_ID = $ACCOUNT_ID"
        echo "  CLOUDFLARE_API_TOKEN  = (hidden)"
        echo ""
        echo "CI will now auto-deploy on push to main."
    silent: true

  # Backward-compatible aliases (Workers was previously unprefixed)
  dev:
    desc: "Alias for cf:dev"
    cmds: [{ task: cf:dev }]
  start:
    desc: "Alias for cf:start"
    cmds: [{ task: cf:start }]
  stop:
    desc: "Alias for cf:stop"
    cmds: [{ task: cf:stop }]
  restart:
    desc: "Alias for cf:restart"
    cmds: [{ task: cf:restart }]
  logs:
    desc: "Alias for cf:logs"
    cmds: [{ task: cf:logs }]
  test:
    desc: "Alias for cf:test"
    cmds: [{ task: cf:test }]
  test:ci:
    desc: "Alias for cf:test:ci"
    cmds: [{ task: "cf:test:ci" }]
  deploy:
    desc: "Alias for cf:deploy"
    cmds: [{ task: cf:deploy }]
  login:
    desc: "Alias for cf:login"
    cmds: [{ task: cf:login }]
  screenshots:
    desc: "Alias for cf:screenshots"
    cmds: [{ task: cf:screenshots }]
  videos:
    desc: "Alias for cf:videos"
    cmds: [{ task: cf:videos }]
  sync-demo:
    desc: "Alias for cf:sync-demo"
    cmds: [{ task: cf:sync-demo }]
  docs:
    desc: "Alias for cf:docs"
    cmds: [{ task: cf:docs }]

  # ╔══════════════════════════════════════════════╗
  # ║  Fly.io / Bun (fly:)                         ║
  # ╚══════════════════════════════════════════════╝

  fly:dev:
    desc: "Start Bun server with persistent SSE (port {{.FLY_PORT}})"
    cmds:
      - mkdir -p data
      - bun run server.ts
    env:
      DB_PATH: '{{.FLY_DB_PATH}}'
      PORT: '{{.FLY_PORT}}'

  fly:dev:corrosion:
    desc: "Start Bun server with Corrosion sync (port {{.FLY_PORT}})"
    cmds:
      - mkdir -p data
      - bun run server.ts
    env:
      DB_PATH: '{{.FLY_DB_PATH}}'
      PORT: '{{.FLY_PORT}}'
      USE_CORROSION_DB: 'true'

  fly:start:
    desc: "Start Bun server in background (skips if running)"
    cmds:
      - |
        if curl -s -o /dev/null -w '' {{.FLY_URL}}/ 2>/dev/null; then
          echo "Bun server already running at {{.FLY_URL}}"
          exit 0
        fi
        mkdir -p data .wrangler
        DB_PATH={{.FLY_DB_PATH}} PORT={{.FLY_PORT}} bun run server.ts > {{.FLY_LOG}} 2>&1 &
        for i in $(seq 1 15); do
          curl -s -o /dev/null -w '' {{.FLY_URL}}/ 2>/dev/null && break
          sleep 1
        done
        echo "Bun server ready at {{.FLY_URL}}"
    silent: true

  fly:stop:
    desc: "Stop Bun server"
    cmds:
      - pkill -f "bun run server.ts" || true
    silent: true

  fly:restart:
    desc: "Stop and restart Bun server"
    cmds:
      - task: fly:stop
      - sleep 1
      - task: fly:start

  fly:logs:
    desc: "Follow Bun server logs"
    cmds:
      - tail -f {{.FLY_LOG}}

  fly:test:
    desc: "Run 25 e2e tests against local Bun server"
    cmds:
      - task: fly:start
      - BASE_URL={{.FLY_URL}} bun run test

  fly:test:deployed:
    desc: "Run e2e tests against deployed Fly.io ({{.FLY_DEPLOYED_URL}})"
    cmds:
      - echo "Testing against {{if .CLI_ARGS}}{{.CLI_ARGS}}{{else}}{{.FLY_DEPLOYED_URL}}{{end}}"
      - HEADED=0 BASE_URL={{if .CLI_ARGS}}{{.CLI_ARGS}}{{else}}{{.FLY_DEPLOYED_URL}}{{end}} bun run test

  fly:login:
    desc: "Authenticate with Fly.io (skips if logged in)"
    cmds:
      - |
        if fly auth whoami &>/dev/null; then
          echo "Already authenticated with Fly.io"
          fly auth whoami
          exit 0
        fi
        fly auth login
    silent: true

  fly:launch:
    desc: "Create Fly.io app + volume (one-time, idempotent)"
    cmds:
      - |
        if fly apps list --json 2>/dev/null | grep -q '"{{.FLY_APP}}"'; then
          echo "App {{.FLY_APP}} already exists"
        else
          fly apps create {{.FLY_APP}}
          echo "Created app {{.FLY_APP}}"
        fi
      - |
        if fly volumes list --json 2>/dev/null | grep -q '"name":"data"'; then
          echo "Volume 'data' already exists"
        else
          fly volumes create data --region {{.FLY_REGION}} --size 1 --yes
          echo "Created volume 'data'"
        fi
    silent: true

  fly:deploy:
    desc: "Deploy to Fly.io (creates app + volume if needed)"
    cmds:
      - task: fly:launch
      - fly deploy

  # ╔══════════════════════════════════════════════╗
  # ║  Service Worker (sw:)                        ║
  # ╚══════════════════════════════════════════════╝

  sw:build:
    desc: "Bundle Service Worker (sw/index.ts → static/sw.js)"
    cmds:
      - bun build sw/index.ts --outfile static/sw.js --target browser --minify
      - echo "Built static/sw.js ($(wc -c < static/sw.js | tr -d ' ') bytes)"

  sw:dev:
    desc: "Build Service Worker + start Workers dev server"
    cmds:
      - task: sw:build
      - task: cf:dev

  # ╔══════════════════════════════════════════════╗
  # ║  Database (db:)                              ║
  # ╚══════════════════════════════════════════════╝

  db:create:
    desc: "Create D1 database on Cloudflare (one-time)"
    cmds:
      - bunx wrangler d1 create {{.D1_DB}}
    silent: true

  db:migrate:
    desc: "Apply D1 migrations locally"
    cmds:
      - bunx wrangler d1 migrations apply {{.D1_DB}} --local
    silent: true

  db:migrate:remote:
    desc: "Apply D1 migrations to remote database"
    cmds:
      - bunx wrangler d1 migrations apply {{.D1_DB}} --remote

  db:generate:
    desc: "Generate SQL migration from schema.ts changes (drizzle-kit)"
    cmds:
      - npx drizzle-kit generate

  db:studio:
    desc: "Open Drizzle Studio (browser DB explorer)"
    cmds:
      - npx drizzle-kit studio

  # ╔══════════════════════════════════════════════╗
  # ║  Corrosion (corrosion:)                      ║
  # ╚══════════════════════════════════════════════╝

  corrosion:install:
    desc: "Install Corrosion binary locally"
    cmds:
      - |
        if command -v {{.CORROSION_BIN}} &>/dev/null; then
          echo "Corrosion already installed at {{.CORROSION_BIN}}"
          exit 0
        fi
        echo "Installing Corrosion v{{.CORROSION_VERSION}}..."
        mkdir -p bin
        bash scripts/install-corrosion.sh "{{.CORROSION_VERSION}}" "{{.CORROSION_DOWNLOAD_URL}}" "bin"
        echo "Corrosion installed to {{.CORROSION_BIN}}"
    silent: true

  corrosion:start:
    desc: "Start Corrosion agent in background (port {{.CORROSION_PORT}})"
    cmds:
      - task: corrosion:install
      - |
        if curl -s -o /dev/null -w '' {{.CORROSION_AGENT_URL}}/ 2>/dev/null; then
          echo "Corrosion agent already running at {{.CORROSION_AGENT_URL}}"
          exit 0
        fi
        mkdir -p {{.CORROSION_DATA_DIR}} .wrangler
        {{.CORROSION_BIN}} -http-addr :{{.CORROSION_PORT}} -data-dir {{.CORROSION_DATA_DIR}} > {{.CORROSION_LOG}} 2>&1 &
        for i in $(seq 1 15); do
          curl -s -o /dev/null -w '' {{.CORROSION_AGENT_URL}}/ 2>/dev/null && break
          sleep 1
        done
        echo "Corrosion agent ready at {{.CORROSION_AGENT_URL}}"
    silent: true

  corrosion:stop:
    desc: "Stop Corrosion agent"
    cmds:
      - pkill -f "{{.CORROSION_BIN}}" || true
    silent: true

  corrosion:logs:
    desc: "Follow Corrosion agent logs"
    cmds:
      - tail -f {{.CORROSION_LOG}}
